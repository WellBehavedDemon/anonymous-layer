import CoordinationPackets from './index.mjs';

import { expect } from 'chai';

const LENGTH_HEADER = 256; // octets, also known as "bytes"

// length in octets for the symmetric cryptography key (128-bits)
const LENGTH_KEY = 16; // octets, also known as "bytes"

// all defined types for coordination packets
const TYPE_COORDINATION_FORWARD_IPV4_WEBSOCKET                  = 0;
const TYPE_COORDINATION_FORWARD_IPV4_UDP                        = 1;
const TYPE_COORDINATION_FORWARD_IPV6_WEBSOCKET                  = 2;
const TYPE_COORDINATION_FORWARD_IPV6_UDP                        = 3;
const TYPE_COORDINATION_REDIRECT_IPV4_WEBSOCKET                 = 4;
const TYPE_COORDINATION_REDIRECT_IPV4_UDP                       = 5;
const TYPE_COORDINATION_REDIRECT_IPV6_WEBSOCKET                 = 6;
const TYPE_COORDINATION_REDIRECT_IPV6_UDP                       = 7;

const TYPE_COORDINATION_ANNOUNCE_PEER_IPV4_WEBSOCKET            = 12;
const TYPE_COORDINATION_ANNOUNCE_PEER_IPV4_UDP                  = 13;
const TYPE_COORDINATION_ANNOUNCE_PEER_IPV6_WEBSOCKET            = 14;
const TYPE_COORDINATION_ANNOUNCE_PEER_IPV6_UDP                  = 15;

const REPLY_TYPE_IPV4_WEBSOCKET                                 = 0;
const REPLY_TYPE_IPV4_UDP                                       = 1;
const REPLY_TYPE_IPV6_WEBSOCKET                                 = 2;
const REPLY_TYPE_IPV6_UDP                                       = 3;

// offsets that are common for coordination packets of any type
// offset #0 is where the checksum is stored
// offset #2 is where the octets that are the dividend begin
// offset #236 is where the real length (header not included) is stored
// offset #238 is where the next length (header not included) is stored
// offset #240 is where the decryption key is stored

const OFFSET_CHECKSUM                                           = 0;
const OFFSET_TYPE                                               = 2;
const OFFSET_REPLY_TYPE                                         = 3;
const OFFSET_SHIFT_TIME_IDLE                                    = 4;
const OFFSET_SHIFT_TIME_TOTAL                                   = 5;
const OFFSET_SHIFT_DATA_AVERAGE                                 = 6;
const OFFSET_SHIFT_DATA_TOTAL                                   = 7;
const OFFSET_FLAGS_32BITS                                       = 8;
const OFFSET_LENGTH_REAL                                        = 236;
const OFFSET_LENGTH_NEXT                                        = 238;
const OFFSET_KEY_DECRYPTION                                     = 240;

const OFFSET_REPLY_IPV4_PORT                                    = 14;
const OFFSET_REPLY_IPV4_HOST                                    = 16;
const OFFSET_REPLY_IPV6_PORT                                    = 14;
const OFFSET_REPLY_IPV6_HOST                                    = 32;

const OFFSET_SHARED_SECRET                                      = 64 + 0;
const OFFSET_REMAINDER                                          = 64 + 16;

// offsets for TYPE_COORDINATION_ANNOUNCE_PEER_IPV4_WEBSOCKET

const OFFSET_ANNOUNCE_PEER_IPV4_WEBSOCKET_PORT                  = 12;
const OFFSET_ANNOUNCE_PEER_IPV4_WEBSOCKET_ADDRESS               = 16;

// offsets for TYPE_COORDINATION_ANNOUNCE_PEER_IPV4_UDP

const OFFSET_ANNOUNCE_PEER_IPV4_UDP_PORT                        = 12;
const OFFSET_ANNOUNCE_PEER_IPV4_UDP_ADDRESS                     = 16;

// offsets for TYPE_COORDINATION_ANNOUNCE_PEER_IPV6_WEBSOCKET

const OFFSET_ANNOUNCE_PEER_IPV6_WEBSOCKET_PORT                  = 12;
const OFFSET_ANNOUNCE_PEER_IPV6_WEBSOCKET_ADDRESS               = 16;

// offsets for TYPE_COORDINATION_ANNOUNCE_PEER_IPV6_UDP

const OFFSET_ANNOUNCE_PEER_IPV6_UDP_PORT                        = 12;
const OFFSET_ANNOUNCE_PEER_IPV6_UDP_ADDRESS                     = 16;

// offsets for TYPE_COORDINATION_FORWARD_IPV4_WEBSOCKET

const OFFSET_FORWARD_IPV4_WEBSOCKET_PORT                        = 12;
const OFFSET_FORWARD_IPV4_WEBSOCKET_ADDRESS                     = 16;

// offsets for TYPE_COORDINATION_FORWARD_IPV4_UDP

const OFFSET_FORWARD_IPV4_UDP_PORT                              = 12;
const OFFSET_FORWARD_IPV4_UDP_ADDRESS                           = 16;

// offsets for TYPE_COORDINATION_FORWARD_IPV6_WEBSOCKET

const OFFSET_FORWARD_IPV6_WEBSOCKET_PORT                        = 12;
const OFFSET_FORWARD_IPV6_WEBSOCKET_ADDRESS                     = 16;

// offsets for TYPE_COORDINATION_FORWARD_IPV6_UDP

const OFFSET_FORWARD_IPV6_UDP_PORT                              = 12;
const OFFSET_FORWARD_IPV6_UDP_ADDRESS                           = 16;

// offsets for TYPE_COORDINATION_REDIRECT_IPV4_WEBSOCKET

const OFFSET_REDIRECT_IPV4_WEBSOCKET_PORT                       = 12;
const OFFSET_REDIRECT_IPV4_WEBSOCKET_ADDRESS                    = 16;

// offsets for TYPE_COORDINATION_FORWARD_IPV4_UDP

const OFFSET_REDIRECT_IPV4_UDP_PORT                             = 12;
const OFFSET_REDIRECT_IPV4_UDP_ADDRESS                          = 16;

// offsets for TYPE_COORDINATION_REDIRECT_IPV6_WEBSOCKET

const OFFSET_REDIRECT_IPV6_WEBSOCKET_PORT                       = 12;
const OFFSET_REDIRECT_IPV6_WEBSOCKET_ADDRESS                    = 16;

// offsets for TYPE_COORDINATION_REDIRECT_IPV6_UDP

const OFFSET_REDIRECT_IPV6_UDP_PORT                             = 12;
const OFFSET_REDIRECT_IPV6_UDP_ADDRESS                          = 16;

// polynomial modulus for packet checksum
// expression: x^17 + x^3 + 1
// binary: 0b10000000000001001
const PACKET_CHECKSUM_MODULUS = 0b10000000000001001;

// uses network byte order (big-endian) for integers
const EXTRACT_UINT16 = (buffer, offset) => {

    let accumulator = 0;
    accumulator = accumulator | ((buffer[(offset + 0) | 0]) << 8);
    accumulator = accumulator | ((buffer[(offset + 1) | 0]) << 0);

    return accumulator;

};

describe('CoordinationPackets', () => {

    const POLYNOMIAL_DEGREE = (polynomial) => (31 - Math.clz32(polynomial)) | 0;

    const BUFFER_POLYNOMIAL_MODULUS = (buffer, offset, length, modulus) => {

        const degreeModulus = POLYNOMIAL_DEGREE(modulus);

        let accumulator = 0;
        let index = offset;
        while (index < length) {

            accumulator = (accumulator << 8) | buffer[index];

            let degreePolynomial = POLYNOMIAL_DEGREE(accumulator);
            while (degreePolynomial >= degreeModulus) {

                const shift = (degreePolynomial - degreeModulus) | 0;
                const subtractor = modulus << shift;
                accumulator = accumulator ^ subtractor;

                degreePolynomial = POLYNOMIAL_DEGREE(accumulator);

            }

            index = (index + 1) | 0;

        }

        return accumulator;

    };

    const COMMON_HEADER_CHECK = (buffer, typeA, keyA, lengthRealA, lengthNextA) => {

        // 128-bits symmetric cryptography key
        expect(keyA).to.have.lengthOf(16);

        // 16-bits for any length
        expect(lengthRealA).to.be.lessThan(1 << 16).and.greaterThanOrEqual(0);
        expect(lengthNextA).to.be.lessThan(1 << 16).and.greaterThanOrEqual(0);

        const typeB = buffer[OFFSET_TYPE];
        expect(typeA).to.equal(typeB);

        const lengthRealB = EXTRACT_UINT16(buffer, OFFSET_LENGTH_REAL);
        const lengthNextB = EXTRACT_UINT16(buffer, OFFSET_LENGTH_NEXT);
        expect(lengthRealA).to.equal(lengthRealB);
        expect(lengthNextA).to.equal(lengthNextB);

        const keyB = buffer.subarray(
            OFFSET_KEY_DECRYPTION,
            (OFFSET_KEY_DECRYPTION + LENGTH_KEY) | 0,
        );

        let index = 0;
        while (index < LENGTH_KEY) {

            const keyDataA = keyA[index];
            const keyDataB = keyB[index];
            expect(keyDataA).to.equal(keyDataB);

            index = (index + 1) | 0;

        }

        const checksumA = EXTRACT_UINT16(buffer, OFFSET_CHECKSUM);

        const checksumB = BUFFER_POLYNOMIAL_MODULUS(
            buffer,
            2, // offset where the dividend octets start
            LENGTH_HEADER,
            PACKET_CHECKSUM_MODULUS,
        );

        expect(checksumA).to.equal(checksumB);

    };

    const TEST_CASES_A = Object.freeze([
        {
            text: {
                type: TYPE_COORDINATION_FORWARD_IPV6_WEBSOCKET,
                key: new Uint8Array([
                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
                ]),
                lengthReal: 0x1A85,
                lengthNext: 0x351D,
                destination: Object.freeze({
                    host: '::1',
                    port: 11412, // 0x2C94
                }),
            },
            binary: new Uint8Array([
                0xBF, 0x41, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x2C, 0x94, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x1A, 0x85, 0x35, 0x1D,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
            ]),
        },
        {
            text: {
                type: TYPE_COORDINATION_FORWARD_IPV6_WEBSOCKET,
                key: new Uint8Array([
                    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
                    0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
                ]),
                lengthReal: 0x0123,
                lengthNext: 0x0456,
                destination: Object.freeze({
                    host: '2804:187c:81cb:6800:31b7:9570:6f8f:a3b6',
                    port: 11412, // 0x2C94
                }),
            },
            binary: new Uint8Array([
                0x02, 0x44, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x2C, 0x94, 0x00, 0x00,
                0x28, 0x04, 0x18, 0x7C, 0x81, 0xCB, 0x68, 0x00,
                0x31, 0xB7, 0x95, 0x70, 0x6F, 0x8F, 0xA3, 0xB6,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 0x04, 0x56,
                0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
                0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
            ]),
        },
        {
            text: {
                type: TYPE_COORDINATION_REDIRECT_IPV6_WEBSOCKET,
                key: new Uint8Array([
                    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
                    0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
                ]),
                lengthReal: 0x0351,
                lengthNext: 0x0852,
                destination: Object.freeze({
                    host: '2804::a3b6',
                    port: 11412, // 0x2C94
                }),
                reply: Object.freeze({
                    type: REPLY_TYPE_IPV6_UDP,
                    destination: Object.freeze({
                        host: '187c::6f8f',
                        port: 12345, // 0x3039
                    }),
                }),
                sharedSecret: new Uint8Array([
                    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
                    0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
                ]),
                remainder: new Uint8Array([
                    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
                ]),
                shiftTimeIdle: 15,      // (1 << 15) milliseconds, around 32 seconds
                shiftTimeTotal: 20,     // (1 << 20) milliseconds, around 17 minutes
                shiftDataAverage: 12,   // (1 << 12) octets per second, exactly 4 KiB/s
                shiftDataTotal: 22,     // (1 << 22) octets, exactly 4 MiB
            },
            binary: new Uint8Array([
                0xFA, 0xFD, 0x06, 0x03, 0x0F, 0x14, 0x0C, 0x16,
                0x00, 0x00, 0x00, 0x00, 0x2C, 0x94, 0x30, 0x39,
                0x28, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0xB6,
                0x18, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x8F,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
                0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
                0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x03, 0x51, 0x08, 0x52,
                0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
                0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
            ]),
        },
        {
            text: {
                type: TYPE_COORDINATION_ANNOUNCE_PEER_IPV6_WEBSOCKET,
                key: new Uint8Array([
                    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
                    0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,
                ]),
                lengthReal: 0x0100,
                lengthNext: 0x0000,
                destination: Object.freeze({
                    host: '81cb::6800',
                    port: 11412, // 0x2C94
                }),
            },
            binary: new Uint8Array([
                0xD9, 0xA7, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x2C, 0x94, 0x00, 0x00,
                0x81, 0xCB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
                0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,
            ]),
        },
    ]);

    it('should format text objects into binary packets', () => {

        for (const request of TEST_CASES_A) {

            const { text, binary: binaryA } = request;

            const {
                type: typeA,
                key: keyA,
                lengthReal: lengthRealA,
                lengthNext: lengthNextA,
            } = text;

            const binaryB = new Uint8Array(LENGTH_HEADER);

            CoordinationPackets.format(text, binaryB);

            COMMON_HEADER_CHECK(
                binaryA,
                typeA,
                keyA,
                lengthRealA,
                lengthNextA,
            );

            let index = 0;
            while (index < LENGTH_HEADER) {

                expect(binaryA[index]).to.equal(binaryB[index]);
                index = (index + 1) | 0;

            }

        }

    });

});
